%  PT Parser.ssl	v1.01
%
% Date:  30 Jun 1980
%	 (revised 7 December 2009)
%
% Author:  Alan Rosselet
%
% Abstract
%
%     This module parses the syntax token stream emitted by the scanner
%   and emits a postfix stream of tokens to the semantic analyzer
%   module.  The parser detects and repairs syntax errors so that the
%   token stream emitted to the semantic analyzer is syntactically
%   legal (except for the special case of declaration phase errors - see
%   comment in the Block routine below).

Input :
	% Keywords must be first both here and in stdIdentifiers,
	% and they must appear in the same order

    pDiv            'div'
	firstKeywordToken = pDiv
	pMod            'mod'
	pOr             'or'
	pAnd            'and'
	pThen           'then'
	pElse           'else'
	pOf             'of'
	pEnd            'end'
	pDo             'do'
	pArray          'array'
	pFile           'file'
	pPacked         'packed'
	pVar            'var'
	pType           'type'
	pIf             'if'
	pCase           'case'
	pWhile          'while'
	pUsing          'using'
	pVal            'val'
	pDef            'def'
	pUnless         'unless'
	pElsif          'elsif'
	pBreak          'break'
	pWhen           'when'
	pModule         'module'
	lastKeywordToken = pModule

	pIdentifier
	firstCompoundInputToken = pIdentifier
	pInteger
	pLiteral
	lastCompoundInputToken = pLiteral

	pNewLine
	pEndFile
	pPlus			'+'
	pMinus			'-'
	pStar			'*'
	pDot			'.'
	pComma			','
	pSemicolon		';'
	pColon			':'
	pEquals			'='
	pNotEqual		'!='
	pLess			'<'
	pLessEqual		'<='
	pGreaterEqual	'>='
	pGreater		'>'
	pLeftParen		'('
	pRightParen		')'
	pLeftBracket	'['
	pRightBracket	']'
	pDotDot			'..'
    pDoubleEquals   '=='
    pNot            '!'
    pQuestion       '?'
    pDollar         '$'
    pHash           '#'
	lastSyntaxToken = pHash;

Output :
	sIdentifier
	firstSemanticToken = sIdentifier
	firstCompoundSemanticToken = sIdentifier
	sInteger
	sLiteral
	lastCompoundSemanticToken = sLiteral

	sProgram
	sParmBegin
	sParmEnd
	sConst
	sType
	sVar
	sProcedure
	sBegin
	sEnd
	sNegate
	sArray
	sPacked
	sFile
	sRange
	sCaseStmt
	sCaseEnd
	sLabelEnd
	sExpnEnd
	sNullStmt
	sAssignmentStmt
	sSubscript
	sCallStmt
	sFieldWidth
	sIfStmt
	sThen
	sElse
	sWhileStmt
	sEq
	sNE
	sLT
	sLE
	sGT
	sGE
	sAdd
	sSubtract
	sMultiply
	sDivide
	sModulus
	sInfixOr
	sOr
	sInfixAnd
	sAnd
	sNot
	sNewLine
    sPublic
    sModule
    sDo
    sBreakIf
    sSubstring
    sLength
    sIndex
	lastSemanticToken = sIndex;


rules

Program :
	'using' .sProgram
	pIdentifier .sIdentifier
	{[
	    | ',' :
		pIdentifier .sIdentifier
	    | * :
		>
	]}
	.sParmEnd
	@Block
	@ProgramStatements;
		
Block :
    % In Garnet, declarations must come before statements.
    % PT Pascal allows intermixing of various declarations
    % (constants, types, vars, and procedures), so we
    % preserve this along with our new declarations.
	{[
	    | 'val':
		.sConst
		@ConstantDefinitions
	    | 'type':
		.sType
		@TypeDefinitions
	    | 'var':
		.sVar
		@VariableDeclarations
	    | 'def':
		.sProcedure
		% procedure name
		[
		    | pStar :
			pIdentifier .sIdentifier .sPublic
		    | pIdentifier :
			.sIdentifier
		]
		@ProcedureHeading
		@Block
		@BlockStatements
	    | 'module':
		.sModule
		pIdentifier .sIdentifier
		@Block
		@BlockStatements
	    | *:
		>
	]};

ProgramStatements :
	.sBegin
	{
	    [
	    | pEndFile:
	        >
        |*:
            @Statement
	    ]
	}
	.sEnd;

ConstantDefinitions :
	% Accept one or more named constant definitions
	pIdentifier  .sIdentifier
	@ConstantValue;

ConstantValue :
	'='
	[
	    | pInteger:
		.sInteger
	    | pIdentifier:
		.sIdentifier
	    | '-':
		@UnsignedIntegerConstant
		.sNegate
	    | '+':
		@UnsignedIntegerConstant
	    | pLiteral:
		.sLiteral
	];

UnsignedIntegerConstant :
	[
	    | pIdentifier:
		.sIdentifier
	    | pInteger:
		.sInteger
	];

TypeDefinitions :
	% Accept one or more named type definitions.
	pIdentifier  .sIdentifier
	':'  @TypeBody;

TypeBody :
	[
	    | 'packed':
		'array'  .sArray  .sPacked
		'['  @SimpleType  ']'
		'of'  @SimpleType
	    | 'array':
		.sArray
		'['  @SimpleType  ']'
		'of'  @SimpleType
	    | 'file':
		.sFile
		'of'  @SimpleType
	    | *:
		@SimpleType
	];

SimpleType :
	% A simple type is a named type (possibly predefined)
	% or a subrange type specification
	[
	    | pIdentifier:
		.sIdentifier
		[
		    | '..':
			.sRange		%% this may be unnecessary
			@OptionallySignedIntegerConstant
		    | *:
		]
	    | *:
		@OptionallySignedIntegerConstant
		'..'  .sRange
		@OptionallySignedIntegerConstant
	];

OptionallySignedIntegerConstant :
	[
	    | '-':
		@UnsignedIntegerConstant
		.sNegate
	    | '+':
		@UnsignedIntegerConstant
	    | *:
		@UnsignedIntegerConstant
	];

VariableDeclarations :
	% Accept one or more variable declarations.
	pIdentifier  .sIdentifier
	{[
	    | pComma: pIdentifier .sVar .sIdentifier
	    | ':' : >
	]}
	@TypeBody;

ProcedureHeading :
	% Accept zero or more procedure formal parameter declarations.
	[
	    | '(':
		{
		    % formal parameter identifier
		    [
			| 'var':
			    pIdentifier  .sIdentifier
			    .sVar
			| *:
			    pIdentifier  .sIdentifier
		    ]
		    ':'
		    % type identifier
		    pIdentifier  .sIdentifier
		    [
			| ',':
			| *:
			    >
		    ]
		}
		')'
	    | *:
	]
	';'
	.sParmEnd;

Statement :
	[
	    | pIdentifier:
		@AssignmentOrCallStmt
	    | 'if':
		@IfStmt
		| 'unless':
		@UnlessStmt
	    | 'while':
		@WhileStmt
	    | 'case':
		@CaseStmt
	    | 'do':
		@DoStmt
	    | *:
		?
		.sNullStmt
	];

AssignmentOrCallStmt :
	[
	    | '=':
		.sAssignmentStmt
		.sIdentifier	% identifier accepted in the Statement rule
		@Expression
		.sExpnEnd
	    | '[':
		.sAssignmentStmt
		.sIdentifier
		.sSubscript
		@Expression
		.sExpnEnd
		']'  '='
		@Expression
		.sExpnEnd
	    | *:
		@CallStmt
	];

CallStmt :
	.sCallStmt
	.sIdentifier	% procedure identifier accepted in the Statement rule
	% accept zero or more actual parameters
	[
	    | '(':
		{
		    @Expression
		    .sExpnEnd
		    % allow a field width specification to occur in calls
		    % to the standard procedures write and writeln
		    [
			| ':':
			    .sFieldWidth
			    @Expression
			    .sExpnEnd
			| *:
		    ]
		    [
			| ',':
			| *:
			    >
		    ]
		}
		')'
	    | *:	% no actual parameters
	]
	.sParmEnd;

BlockStatements :
	.sBegin
	{[
	    | 'end':
	        .sEnd
	        >
        |*:
        @Statement
	]};

%	{
%	    @Statement
%	    [
%		| ';':
%		| 'end':
%		    .sEnd
%		    >
%	    ]
%	};

IfStmt :
	.sIfStmt
	@Expression
	.sExpnEnd
	'then' .sThen
	.sBegin
	{[
	    | 'end':
	    .sEnd
	    >
	    | 'else':
        .sEnd
        .sElse
        @BlockStatements
        >
	    | 'elsif':
	    .sEnd
	    .sElse
	    .sBegin
	    @IfStmt
	    >
	    | *:
	    @Statement
	]};

UnlessStmt :
    .sIfStmt
    @Expression
    .sNot
    .sExpnEnd
    'then' .sThen
    @BlockStatements;

CaseStmt :
	.sCaseStmt
	@Expression
	.sExpnEnd
	[
	    | ';':
		% since case alternatives cannot be null, allow
		% for the common situation of an extra semicolon
		% at the end of the list of case alternatives.
		[
		    | 'when':
            	    @CaseAlternative
		    | 'else':
		    @CaseDefault
		    | 'end':
		]
	]
	.sCaseEnd;

CaseAlternative :
	% A case alternative is a statement labelled by
	% one or more optionally signed integer constants

	{
	    @OptionallySignedIntegerConstant
	    [
		| ',':
		| *:
		    >
	    ]
	}
	'then'
	.sLabelEnd
	.sBegin
	{[
	    | 'when':
	    .sEnd
	    @CaseAlternative
	    >
	    | 'else':
	    .sEnd
	    @CaseDefault
	    >
	    | 'end':
	    .sEnd
	    >
	    |*:
	    @Statement
	]};

CaseDefault :
    @BlockStatements;

WhileStmt :
	.sWhileStmt
	@Expression
	.sExpnEnd
	'do'
	@BlockStatements;

DoStmt :
	.sDo
	.sBegin
	{[
		| 'break':
		 'if'
		 .sEnd
		 .sBreakIf
		 @Expression
		 .sExpnEnd
		 .sBegin
		    >
	    | ';':
	    |*:
	    @Statement
	]}
	.sEnd
	.sExpnEnd;

Expression :
	@SimpleExpression
	[
	    | '==':
		@SimpleExpression  .sEq
	    | '!=':
		@SimpleExpression  .sNE
	    | '<':
		@SimpleExpression  .sLT
	    | '<=':
		@SimpleExpression  .sLE
	    | '>':
		@SimpleExpression  .sGT
	    | '>=':
		@SimpleExpression  .sGE
	    | *:
	];

SimpleExpression :
	[
	    | '+':
		@Term
	    | '-':
		@Term  .sNegate
	    | *:
		@Term
	]
	{[
	    | '+':
		@Term  .sAdd
	    | '-':
		@Term  .sSubtract
	    | 'or':
		.sInfixOr  @Term  .sOr
	    | *:
		>
	]};

Term :
    [
        |'$':
            @Term
            .sSubstring
        |*:
            @SubTerm
    ];

SubTerm :
	@Factor
	{[
	    | '*':
		@Factor  
        .sMultiply
	    | 'div':
		@Factor  
        .sDivide
	    | 'mod':
		@Factor  
        .sModulus
	    | 'and':
		.sInfixAnd  
        @Factor  
        .sAnd
        | '?':
        @Factor
        .sIndex
	    | *:
		>
	]};

Factor :
	[
	    | pIdentifier:
		.sIdentifier
		@IdentifierExtension
	    | pInteger:
		.sInteger
	    | '(':
		@Expression  ')'
	    | '!':
		@Factor
		.sNot
        | '#':
        @Factor
        .sLength
	    | pLiteral:
		.sLiteral
	    | 'file':
		.sFile '(' @Expression ')'
		.sExpnEnd
	];

IdentifierExtension :
	% Handle subscripts and function actual parameter lists
	[
	    | '[':
		.sSubscript
		@Expression  ']'
		.sExpnEnd
	    | '(':
		.sParmBegin
		@Expression  ')'
		.sExpnEnd
		.sParmEnd
	    | *:
	];

end
