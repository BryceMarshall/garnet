%  PT Parser.ssl	v1.01
%
% Date:  30 Jun 1980
%	 (revised 7 December 2009)
%
% Author:  Alan Rosselet
%
% Abstract
%
%     This module parses the syntax token stream emitted by the scanner
%   and emits a postfix stream of tokens to the semantic analyzer
%   module.  The parser detects and repairs syntax errors so that the
%   token stream emitted to the semantic analyzer is syntactically
%   legal (except for the special case of declaration phase errors - see
%   comment in the Block routine below).

Input :
	% Keywords must be first both here and in stdIdentifiers,
	% and they must appear in the same order

    pDiv            'div'
	firstKeywordToken = pDiv
	pMod            'mod'
	pOr             'or'
	pAnd            'and'
	pThen           'then'
	pElse           'else'
	pOf             'of'
	pEnd            'end'
	pDo             'do'
	pArray          'array'
	pFile           'file'
	pPacked         'packed'
	pVar            'var'
	pType           'type'
	pIf             'if'
	pCase           'case'
	pWhile          'while'
	pUsing          'using'
	pVal            'val'
	pDef            'def'
	pUnless         'unless'
	pElsif          'elsif'
	pBreak          'break'
	pWhen           'when'
	pModule         'module'
	lastKeywordToken = pModule

	pIdentifier
	firstCompoundInputToken = pIdentifier
	pInteger
	pLiteral
	lastCompoundInputToken = pLiteral

	pNewLine
	pEndFile
	pPlus			'+'
	pMinus			'-'
	pStar			'*'
	pDot			'.'
	pComma			','
	pSemicolon		';'
	pColon			':'
	pEquals			'='
	pNotEqual		'!='
	pLess			'<'
	pLessEqual		'<='
	pGreaterEqual	'>='
	pGreater		'>'
	pLeftParen		'('
	pRightParen		')'
	pLeftBracket	'['
	pRightBracket	']'
	pDotDot			'..'
    pDoubleEquals   '=='
    pNot            '!'
    pQuestion       '?'
    pDollar         '$'
    pHash           '#'
	lastSyntaxToken = pHash;

Output :
	sIdentifier
	firstSemanticToken = sIdentifier
	firstCompoundSemanticToken = sIdentifier
	sInteger
	sLiteral
	lastCompoundSemanticToken = sLiteral

	sProgram
	sParmBegin
	sParmEnd
	sConst
	sType
	sVar
	sProcedure
	sBegin
	sEnd
	sNegate
	sArray
	sPacked
	sFile
	sRange
	sCaseStmt
	sCaseEnd
	sLabelEnd
	sExpnEnd
	sNullStmt
	sAssignmentStmt
	sSubscript
	sCallStmt
	sFieldWidth
	sIfStmt
	sThen
	sElse
	sWhileStmt
	sEq
	sNE
	sLT
	sLE
	sGT
	sGE
	sAdd
	sSubtract
	sMultiply
	sDivide
	sModulus
	sInfixOr
	sOr
	sInfixAnd
	sAnd
	sNot
	sNewLine
    sPublic
    sModule
    sDo
    sBreakIf
    sSubstring
    sLength
    sIndex
	lastSemanticToken = sIndex;


rules

% Changed Program rule to use 'using' keyword with 
% multiple arguments, removed program parameters,
% and added a call to parse declarations as well as statements.
Program :
	'using' .sProgram
	pIdentifier .sIdentifier
	{[
	    | ',' :
		pIdentifier .sIdentifier
	    | * :
		>
	]}
	.sParmEnd
	@Block
	@ProgramStatements;
		
Block :
    % In Garnet, declarations must come before statements.
    % PT Pascal allows intermixing of various declarations
    % (constants, types, vars, and procedures), so we
    % preserve this along with our new declarations.
	{[
	    | 'val':        %Changed 'const' to 'val'
		    .sConst
		    @ConstantDefinitions
	    | 'type':
		    .sType
		    @TypeDefinitions
	    | 'var':
		    .sVar
		    @VariableDeclarations
	    | 'def':        %Changed 'procedure' to 'def'
		    .sProcedure
		    % parse procedure name here, 
            % with optional '*' to denote a public method
		    [
		        | pStar :
		    	pIdentifier .sIdentifier .sPublic
		        | pIdentifier :
		    	.sIdentifier
		    ]
		    @ProcedureHeading
            % This will handle the nested nature of 
            % function declarations and statements
		    @Block
		    @BlockStatements
	    | 'module':
		    .sModule
		    pIdentifier .sIdentifier
            % This will handle the nested nature of 
            % module declarations and statements
		    @Block
		    @BlockStatements
	    | *:
        % The next token is not part of a declaration, 
        % so end declarations
		>
	]};

ProgramStatements :
	.sBegin
    {[
	    | pIdentifier:
		@AssignmentOrCallStmt
	    | 'if':
		@IfStmt
		| 'unless':
		@UnlessStmt
	    | 'while':
		@WhileStmt
	    | 'case':
		@CaseStmt
	    | 'do':
		@DoStmt
        |';':
        |*:
        >
    ]}
    .sEnd;

ConstantDefinitions :
	% Accept exactly one named constant definition 
	pIdentifier  .sIdentifier
	@ConstantValue;

ConstantValue :
	'='
	[
	    | pInteger:
		.sInteger
	    | pIdentifier:
		.sIdentifier
	    | '-':
		@UnsignedIntegerConstant
		.sNegate
	    | '+':
		@UnsignedIntegerConstant
	    | pLiteral:
		.sLiteral
	];

UnsignedIntegerConstant :
	[
	    | pIdentifier:
		.sIdentifier
	    | pInteger:
		.sInteger
	];

TypeDefinitions :
	% Accept exactly one named type definition.
	pIdentifier  .sIdentifier
	':'  @TypeBody;

TypeBody :
	[
	    | 'packed':
		'array'  .sArray  .sPacked
		'['  @SimpleType  ']'
		'of'  @SimpleType
	    | 'array':
		.sArray
		'['  @SimpleType  ']'
		'of'  @SimpleType
	    | 'file':
		.sFile
		'of'  @SimpleType
	    | *:
		@SimpleType
	];

SimpleType :
	% A simple type is a named type (possibly predefined)
	% or a subrange type specification
	[
	    | pIdentifier:
		.sIdentifier
		[
		    | '..':
			.sRange		%% this may be unnecessary
			@OptionallySignedIntegerConstant
		    | *:
		]
	    | *:
		@OptionallySignedIntegerConstant
		'..'  .sRange
		@OptionallySignedIntegerConstant
	];

OptionallySignedIntegerConstant :
	[
	    | '-':
		@UnsignedIntegerConstant
		.sNegate
	    | '+':
		@UnsignedIntegerConstant
	    | *:
		@UnsignedIntegerConstant
	];

VariableDeclarations :
	% Accept one or more variable names, and declare them all to be
    % a single type
	pIdentifier  .sIdentifier
	{[
	    | pComma: pIdentifier .sVar .sIdentifier
	    | ':' : >
	]}
	@TypeBody;

ProcedureHeading :
	% Accept zero or more procedure formal parameter declarations.
	[
	    | '(':
		{
            [
            % If parameter is preceded by 'var', 
            % consume it and check if another exists
            | 'var':
                .sVar
                @ProcedureParam
                [
                | ',':
                % Go into the next iteration, 
                % as another parameter is expected
                | *:
                    >
                ]
            | ')':
                >
            % If parameter is not preceded by 'var',
            % consume it and check if another exists
            | * :
                @ProcedureParam
                [
                | ',':
                | *:
                    >
                ]
            ]}
        | '*':
        ]
	.sParmEnd;

% New rule, handles parameters for routines.
ProcedureParam :
    pIdentifier     % Consume name of parameter
    .sIdentifier
    ':'
    @TypeBody;      % Consume type of parameter


% Removed recognition of the "begin" keyword to open a scope block,
% as well as recognition of the "repeat" keyword to begin a repeat
% statement. Added recognition of the "unless" and "do" keywords to
% begin unless and do statements, respectively. Output an sEnd token
% after the rule in addition to the sBegin/sEnd that enclose the
% statement's block.
Statement :
	[
	    | pIdentifier:
		@AssignmentOrCallStmt
	    | 'if':
		@IfStmt
		| 'unless':
		@UnlessStmt
	    | 'while':
		@WhileStmt
	    | 'case':
		@CaseStmt
	    | 'do':
		@DoStmt
        |';':
	]
    .sEnd;

% Changed references to assignment operator from := to =
AssignmentOrCallStmt :
	[
	    | '=':
		.sAssignmentStmt
		.sIdentifier	% identifier accepted in the Statement rule
		@Expression
		.sExpnEnd
	    | '[':
		.sAssignmentStmt
		.sIdentifier
		.sSubscript
		@Expression
		.sExpnEnd
		']'  '='
		@Expression
		.sExpnEnd
	    | *:
		@CallStmt
	];

CallStmt :
	.sCallStmt
	.sIdentifier	% procedure identifier accepted in the Statement rule
	% accept zero or more actual parameters
	[
	    | '(':
		{
		    @Expression
		    .sExpnEnd
		    % allow a field width specification to occur in calls
		    % to the standard procedures write and writeln
		    [
			| ':':
			    .sFieldWidth
			    @Expression
			    .sExpnEnd
			| *:
		    ]
		    [
			| ',':
			| *:
			    >
		    ]
		}
		')'
	    | *:	% no actual parameters
	]
	.sParmEnd;

% Enter a scope block, matching statements until the "end" keyword is
% matched. Emit an implicit sBegin token, and emit an sEnd upon reaching
% the "end" keyword. This rule is used in cases where only an "end"
% keyword provides the valid syntax required to close the scope.
BlockStatements :
	.sBegin
	{[
	    | 'end':
	        .sEnd
	        >
        |*:
        @Statement
	]};

% Automatically output sBegin due to removal of the explicit "begin" keyword.
% First handle the three separate cases that will cause the statement block
% to close, and match a statement otherwise. The three cases are:
% 1. if the "end" keyword occurs, output sEnd and leave the rule
% 2. if the "else" keyword occurs, output sEnd and sElse, then call
%    BlockStatements to output a "sBegin/statements/sEnd" sequence
% 3. if the "elsif" keyword occurs, output sEnd, sElse, and sBegin,
%    then call IfStmt to handle the expression as nested if statement
%    within the else case
IfStmt :
	.sIfStmt
	@Expression
	.sExpnEnd
	'then' .sThen
	.sBegin
	{[
	    | 'end':
	    .sEnd
	    >
	    | 'else':
        .sEnd
        .sElse
        @BlockStatements
        >
	    | 'elsif':
	    .sEnd
	    .sElse
	    .sBegin
	    @IfStmt
	    >
	    | *:
	    @Statement
	]};

% Added this rule to handle "unless" statements, which are simple negated
% if statements. They are output nearly identically to an if statement,
% with an sNot token included after the expression (which will negate
% the expression in postfix), and the 'elsif' logic removed.
UnlessStmt :
    .sIfStmt
    @Expression
    .sNot
    .sExpnEnd
    'then' .sThen
    .sBegin
    {[
        | 'else':
        .sEnd
        .sElse
        @BlockStatements
        >
        | 'end':
        .sEnd
        >
        |*:
        @Statement
    ]};

% Parsing of the "of" keyword was removed, as it is no longer used
% in Garnet's case statement syntax. Calls to the CaseAlternative rule
% were changed, now entering the rule only upon matching the "when"
% keyword, and entering the CaseDefault rule upon matching "else".
% An "end" keyword also allows for the existence of an empty switch,
% which is valid Garnet syntax.
CaseStmt :
	.sCaseStmt
	@Expression
	.sExpnEnd
	[
	    | ';':
		% since case alternatives cannot be null, allow
		% for the common situation of an extra semicolon
		% at the end of the list of case alternatives.
		[
		    | 'when':
            @CaseAlternative
		    | 'else':
		    @CaseDefault
		    | 'end':
		]
	]
	.sCaseEnd;

% Case alternatives were changed to call the CaseAlternative rule
% until the "else" keyword is matched, in which case the CaseDefault
% rule is used in a one-way fashion (that is, zero or more "when"
% cases can be contained in a switch before an "else" case).
% The rule now also allows for empty case bodies, containing zero
% statements, which is also valid Garnet due to the presence of
% the "end" keyword.
CaseAlternative :
	% A case alternative is a statement labelled by the "when" keyword
	{
	    @OptionallySignedIntegerConstant
	    [
		| ',':
		| *:
		    >
	    ]
	}
	'then'
	.sLabelEnd
	.sBegin
	{[
	    | 'when':
	    .sEnd
	    @CaseAlternative
	    >
	    | 'else':
	    .sEnd
	    @CaseDefault
	    >
	    | 'end':
	    .sEnd
	    >
	    |*:
	    @Statement
	]};

% The default case statement is handled by the BlockStatements
% rule, repeatedly matching and outputting statement sequences
% until an "end" keyword is reached.
CaseDefault :
    @BlockStatements;

WhileStmt :
	.sWhileStmt
	@Expression
	.sExpnEnd
	'do'
	@BlockStatements;

% PT's "repeat" statement was removed and replaced with Garnet's
% "do" statement. This generalized loop allows for an optional
% block of statements, followed by a required "break if" statement
% (which contains an expression representing the break condition),
% and a second optional block of statements.
DoStmt :
	.sDo
	.sBegin
	{[
		| 'break':
		 'if'
		 .sEnd
		 .sBreakIf
		 @Expression
		 .sExpnEnd
		 @BlockStatements
		 >
	    |*:
	    @Statement
	]}
	.sExpnEnd;

Expression :
	@SimpleExpression
	[
	    | '==':
		@SimpleExpression  .sEq
	    | '!=':
		@SimpleExpression  .sNE
	    | '<':
		@SimpleExpression  .sLT
	    | '<=':
		@SimpleExpression  .sLE
	    | '>':
		@SimpleExpression  .sGT
	    | '>=':
		@SimpleExpression  .sGE
	    | *:
	];

SimpleExpression :
	[
	    | '+':
		@Term
	    | '-':
		@Term  .sNegate
	    | *:
		@Term
	]
	{[
	    | '+':
		@Term  .sAdd
	    | '-':
		@Term  .sSubtract
	    | 'or':
		.sInfixOr  @Term  .sOr
	    | *:
		>
	]};

Term :
    %Term now calls SubTerm to account for the new precedence level of $
	@SubTerm
	{[
	    | '*':
		@SubTerm  
        .sMultiply
	    | 'div':
		@SubTerm 
        .sDivide
	    | 'mod':
		@SubTerm 
        .sModulus
	    | 'and':
		.sInfixAnd  
        @SubTerm 
        .sAnd
        %Added new index operator at mid-precedence
        | '?':
        @SubTerm
        .sIndex
	    | *:
		>
	]};

%New rule to allow for new precedence level of $ operator
SubTerm :
    @Factor
    {[
        %$ operator can take SimpleExpression operators as its parameters
        | '$':
    		@SimpleExpression
    		'..'
    		@SimpleExpression
            .sSubstring
        | *:
            >
    ]};

Factor :
	[
	    | pIdentifier:
		.sIdentifier
		@IdentifierExtension
	    | pInteger:
		.sInteger
	    | '(':
		@Expression  ')'
	    | '!':
		@Factor
		.sNot
        %Added new length operator at highest precedence level
        | '#':
        @Factor
        .sLength
	    | pLiteral:
		.sLiteral
	    | 'file':
		.sFile '(' @Expression ')'
		.sExpnEnd
	];

IdentifierExtension :
	% Handle subscripts and function actual parameter lists
	[
	    | '[':
		.sSubscript
		@Expression  ']'
		.sExpnEnd
	    | '(':
		.sParmBegin
		@Expression  ')'
		.sExpnEnd
		.sParmEnd
	    | *:
	];

end
